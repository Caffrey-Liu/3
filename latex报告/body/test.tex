\chapter{测试与开发过程}
\section{传播延时方面}
\begin{itemize}
    \item 最初方案：对float数组元素逐个传输，传完一次数据约耗时2s。
    \item 原因是每传输一次数据都会调用一次Wifi模块，经过测试，调用WiFi模块是占用整个传输时间最大比例的，所以后续改进都从减少调用Wifi模块次数的角度考虑。
    \item 改进方案：将float数组拼接为字符串，传完一次数据约耗时0.6s。
    \item 该方案确实减少了Wifi模块调用时间从而大大减少了传输时间。但是在对数据进行类型转换的时候，由float型（4字节）转换为对应的string型（8字节）时，数据的字节数发生了增长，后续改进都针对数据字节规模进行了考虑。考虑尝试使用UDP进行传输，但是UDP丢包问题可能使得服务器在单位时间内接收的数据量更少，得不偿失。后又考虑把几次数据合为一个字符串进行传输，但是在网络协议中包的大小有着明确的限制，不论合成几次数据都会分为多个包进行发送，并且合成数据时也浪费了大量的时间，经过考虑后，放弃了UDP的传输方式。
    \item 最终方案：在ESP32上对float做乘100运算后类型转换为int，而后拼为字符串进行传输，传完一组数据约耗时0.3s。
    \item 这个方法降低了转换后字符串的长度，并且后续处理数据也更为简单方便。
    \end{itemize}
\section{WiFi连接方式}
\begin{itemize}
    \item 最初方案：使用ESP32开设热点即AP模式，接收设备连接进行数据接收。
    \item 但是由于ESP32本身没有网络环境，外部设备连接后会使得设备无法访问外部网络，最后放弃了这个方案。
    \item 改进方案：ESP32调用自身WiFi模块，利用事先输入好的Wifi名称和密码连接对应网络，外部设备连接同一个wifi网络，在局域网内进行数据传输。
    \item 适用范围提升了许多，但是每次更换网络环境，需要重新烧写ESP32，十分繁琐。
    \item 第二次改进：ESP32的AP模式可以使其作为服务器向外部连接的提供一个html网页来输入想要连接的网络名称和密码。
    \item 虽然适配了复杂多变的网络环境，但是每次断电，启动都需要输入一次环境配置，也不够人性化。
    \item 最终方案：保存上次连接的WiFi信息，启动后先尝试连接上次连接的WiFi，不成功再开启AP模式，用外部设备连接，输入新的网络配置。
    \end{itemize}
\section{数据接收服务}
\begin{itemize} 
    \item 最初方案：使用Java编写的Service服务器，与ESP32建立Socket连接。
    \item 每次ESP32重新启动时，会递交新的Socket，但是之前的服务器仍然在等待上一次建立连接的Socket的输入流，只能重启服务器才能再次进行连接。
    \item 最终方案：建立两个Service对象交替使用，在一个服务器建立连接后，另一个服务器依然在监听Socket请求，当收到新的请求后，结束上一个服务器的线程，并且再次开启一个新的线程用于监听。
\end{itemize}   
\section{插值算法的选择}
\begin{itemize}
    \item 最初方案：简单的取平均值算法。
    \item 速度很快，计算压力较小，实现了图像分辨率的增加，但是计算的参照物少，精度不高，生成的图像比较模糊，细节缺失较多。
    \item 最终方案：二元和三元插值算法。
    \item 相较于之前的算法得出的图像锯齿感有所减少。尽管三元插值算法在图像细节上可能有较好的呈现，但是因为其运算过程复杂，可能导致数据从传输到最终显示在前端页面上有着较大的延迟，所以最后选择了耗时较少的二元插值算法，让图像质量和显示延时取得较好的平衡。
    \end{itemize}
\section{温度区间色彩}
\begin{itemize}
    \item 最初方案：简单的让温度在色彩条带上均匀分布。
    \item 由于温度跨度较大，而实际测温时的温度区间差值较小，使得人和环境的温度都落在色带上较为接近的位置，最终渲染出来的图像颜色较为接近，区分度不高。原本设想温度低于某一个阈值时就将其颜色置为纯色，使得背景颜色不影响主要测温物体颜色的呈现。但是由于测温物体边缘的温度有时与环境相差无几，细节缺失较多，最后呈现出来的图像也并没有达到预想的效果。
    \item 最终方案：根据实际情况，将人体体温附近的温度在色彩区间上占比增加，调整了其他温度区间的色彩区间占比，显著提升了成像的质量。
    \end{itemize}
\section{图片的产生和输出}
\begin{itemize}
    \item 最初方案：将经过处理后的数据封装入image对象中，在本地生成图片，再将本地生成的图片转为Base64编码。
    \item 但是图片刷新速率快，每次运行产生大量图片，给调试者带来了不必要的麻烦。并且由于生产图片需要根据路径存放，也不易于服务器的移植。
    \item 最终方案：将生成图片封装的image对象直接转换为字节流的形式，再对字节流进行Base64编码的转换。
    \item 最终使得图片流式传输，不占用本地资源，同时也节省了图片生成及读取的时间，减少了前端页面的延迟。
    \end{itemize}
\section{服务器的部署}
    \begin{itemize}
    \item 最初方案：服务器部署于本机。
    \item 必须通过局域网才能访问，硬件部分每次重新启动服务器也需要重新启动。即使通过端口映射到学校网络实现连接学校网络即可访问，也并不是十分稳定。
    \item 最终方案：将服务器部署在阿里云ESC实例上，使其可以通过公网ip访问。
    \item 只要有网络环境和浏览器的设备即可访问。
    \end{itemize}
\section{前端页面的改进}
\begin{itemize}
    \item 最初方案：在进行html编写时采用固定像素的方式布局页面。
    \item 在常见PC端可以正常展现画面，但是在其他移动设备上页面效果非常僵化，页面布局混乱。
    \item 最终方案：进行整个页面的重新设计，设定html网页布局，分配好容器，元素大小使用容器相对值进行设定。
    \item 使得Web适配了PC端、移动端，在不同的设备上使用也能获得较为良好的使用体验，真正实现了多端访问的需求。
    \end{itemize}
